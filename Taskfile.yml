version: "3"

tasks:
  build:
    desc: Build the binary in a tmp location.
    cmds:
      - go build -o ./tmp/main main.go

  run:
    desc: Run the binary with optional environment variables.
    summary: |
      Run the binary with optional environment variables.
      Configuration is done via environment variables, not CLI arguments.
    cmds:
      - go run -cover main.go

  dev:
    desc: Start the app in dev mode with live-reloading.
    summary: |
      Start the app in dev mode with live-reloading.

      This command starts a local version of the app with reloading enabled.
      So when the code changes the server restarts. It also watches for changes in `templ` and `tailwind` classes.
      We reload using air. It also makes sure that the docker containers are started first that the app depends on.
      Database migrations are run automatically after containers are ready.
    env:
      BANTERBUS_LOG_LEVEL: debug
    cmds:
      - docker compose --profile monitoring --profile test --profile other up -d --force-recreate --remove-orphans
      - concurrently "air" "task watch"

  lint:
    desc: Runs the linter.
    cmds:
      - golangci-lint run --fix ./...

  format:
    desc: Runs the formatter.
    cmds:
      - golangci-lint run --fix ./...
      - sqlfluff format internal/store/db/sqlc/ --dialect postgres --disable-progress-bar
      - templ fmt internal/views
      - rustywind internal/views/ --write
      - tofu fmt -recursive

  tests:
    desc: Runs all the tests.
    cmds:
      - gotestsum

  tests:unit:
    desc: Runs all the unit tests.
    cmds:
      - mkdir -p coverage
      - gotestsum --format testname --hide-summary=skipped -- -coverprofile coverage/unit.out -cover -covermode=atomic -skip '^TestIntegration' ./internal/... {{.CLI_ARGS}}

  tests:integration:
    desc: Runs all the integration tests.
    cmds:
      - mkdir -p coverage
      - gotestsum --format testname --hide-summary=skipped -- -coverprofile coverage/integration.out -cover -covermode=atomic -run ^TestIntegration ./internal/... {{.CLI_ARGS}}

  tests:e2e:
    desc: Runs e2e tests with playwright and collects coverage from the running server.
    env:
      SHOW_VOTING_SCREEN_FOR: 5s
      SHOW_REVEAL_SCREEN_FOR: 5s
      SHOW_QUESTION_SCREEN_FOR: 15s
      SHOW_SCORE_SCREEN_FOR: 5s

      GOCOVERDIR: ./coverage/e2e
      RUN_WITH_COVERAGE: true

      BANTERBUS_ENVIRONMENT: test
      BANTERBUS_WEBSERVER_PORT: 8081
      BANTERBUS_WEBSERVER_HOST: 0.0.0.0
      BANTERBUS_DB_HOST: localhost
      BANTERBUS_DB_USERNAME: postgres
      BANTERBUS_DB_PASSWORD: postgres

      BANTERBUS_PLAYWRIGHT_URL: http://localhost:8081
      BANTERBUS_AUTO_RECONNECT: false
    cmds:
      - mkdir -p coverage/e2e
      - |
        concurrently \
          --names "SERVER,TESTS" \
          --success first \
          "task run" --kill-others \
           "until curl -sSf http://localhost:8081/health >/dev/null; do sleep 2; done && \
            gotestsum --format testname --hide-summary=skipped --packages='./tests/e2e' -- \
              -coverprofile coverage/e2e-tests.out \
              -cover -covermode=atomic ${CLI_ARGS}"

  tests:e2e:quiet:
    desc: Runs e2e tests with playwright without any logging as this can be super verbose.
    env:
      BANTERBUS_LOG_DISABLED: true
      BANTERBUS_PLAYWRIGHT_URL: http://localhost:8081
      BANTERBUS_WEBSERVER_PORT: 8081
      BANTERBUS_WEBSERVER_HOST: 0.0.0.0
      BANTERBUS_DB_HOST: localhost
      BANTERBUS_DB_USER: postgres
      BANTERBUS_DB_PASSWORD: postgres
    cmds:
      - gotestsum --format dots -- ./tests/e2e/... ${CLI_ARGS}

  tests:e2e:single:
    desc: Interactively select and run a single e2e test or subtest using gum
    cmds:
      - |
        TEMP_FILE=$(mktemp)
        grep -h "^func Test" tests/e2e/*.go | \
          grep -v "TestMain" | \
          sed 's/func \(Test[^(]*\).*/\1/' >> "$TEMP_FILE"

        for file in tests/e2e/*.go; do
          MAIN_TEST=$(grep "^func Test" "$file" | grep -v "TestMain" | sed 's/func \(Test[^(]*\).*/\1/')
          if [ ! -z "$MAIN_TEST" ]; then
            grep 't\.Run(' "$file" | \
              sed 's/.*t\.Run("\([^"]*\)".*/'"$MAIN_TEST"'\/\1/' >> "$TEMP_FILE"
          fi
        done

        TEST_NAME=$(cat "$TEMP_FILE" | sort | gum filter --placeholder "Select e2e test or subtest to run")
        rm "$TEMP_FILE"
        if [ -z "$TEST_NAME" ]; then
          echo "No test selected. Exiting."
          exit 0
        fi
        echo "Running test: $TEST_NAME"

        CLI_ARGS="-run \"${TEST_NAME}\" -v" task tests:e2e

  tests:smoke:
    desc: Runs e2e smoke tests with playwright, expected to run against a live instance i.e. dev or prod.
    env:
      BANTERBUS_LOG_DISABLED: true
    cmds:
      - gotestsum --format standard-verbose -- ./tests/e2e/... -run '^TestSmoke' ${CLI_ARGS}

  coverage:
    desc: Combine and show coverage from all test types
    cmds:
      - mkdir -p coverage

      - echo "Converting e2e server coverage data..."
      - go tool covdata textfmt -i=coverage/e2e -o coverage/e2e-server.out

      - touch coverage/unit.out coverage/integration.out coverage/e2e-tests.out

      - |
        echo "mode: atomic" > coverage/combined.out
        for file in coverage/unit.out coverage/integration.out coverage/e2e-tests.out coverage/e2e-server.out; do
          if [ -f "$file" ] && [ -s "$file" ]; then
            echo "Adding coverage from $file"
            tail -n +2 "$file" >> coverage/combined.out 2>/dev/null || true
          else
            echo "Skipping empty or missing file: $file"
          fi
        done

      - |
        echo "=== FULL PROJECT COVERAGE (including all files) ==="
        go tool cover -func=coverage/combined.out | tail -5
        
         echo ""
         echo "Generating business logic coverage (excluding generated/mock files)..."
         # Simple approach: filter out generated files from combined coverage
         cat coverage/combined.out | grep -v -E "(mocks|_templ\.go|/views/|banterbustest)" > coverage/business-logic.out
         echo ""
         echo "=== BUSINESS LOGIC COVERAGE (excluding mocks, templates, views) ==="
         go tool cover -func=coverage/business-logic.out | tail -5
        
        # For GitLab CI: create the main coverage file as business logic only
        cp coverage/business-logic.out coverage/gitlab-ci.out
        
      - go tool cover -html=coverage/combined.out -o coverage/coverage.html
      - go tool cover -html=coverage/business-logic.out -o coverage/business-logic.html
      - echo "Full coverage report generated at coverage/coverage.html"
      - echo "Business logic coverage report generated at coverage/business-logic.html"

  watch:
    desc: Watch for file changes and run commands, i.e. generate templates or tailwindcss
    env:
      TEMPL_EXPERIMENT: rawgo
    cmds:
      - templ generate -watch --proxy="http://localhost:8080" --open-browser=true &
      - tailwindcss --watch=always -i ./static/css/tailwind.css -o ./static/css/styles.css --minify &
      # TODO: do we want to add watch commands for the following?
      # - mockery --all
      # - sqlc generate

  generate:
    desc: Generates all the code needed for the project i.e. sqlc, templ & tailwindcss
    env:
      TEMPL_EXPERIMENT: rawgo
    cmds:
      - templ generate
      - tailwindcss -i ./static/css/tailwind.css -o ./static/css/styles.css --minify
      - mockery
      - go-enum --noprefix --file=internal/store/db/enums.go
      - sqlc generate
      - gomod2nix generate
      - task: format

  docker:build:
    desc: Build the Docker image
    env:
      LOCAL_IMAGE: banterbus
      FLAKE_TARGET: container
    cmds:
      - nix build .#${FLAKE_TARGET}
      - docker load < result

  docker:publish:
    desc: Build and publish the Docker image
    env:
      LOCAL_IMAGE: banterbus
      FLAKE_TARGET: container
      IMMUTABLE: "true"
    cmds:
      - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
      - |
        if [ "$IMMUTABLE" = "true" ]; then
          if docker pull $IMAGE; then
            echo "Image with tag $IMAGE_TAG already exists. Failing the pipeline."
            exit 1
          fi
        fi
      - task: docker:build
      - docker image tag $LOCAL_IMAGE:latest $IMAGE
      - docker push $IMAGE

  ci:local:
    desc: Run gitlab ci locally
    cmds:
      - nix build .#container-ci && docker load < result
      - docker tag banterbus-dev:latest local-registry.gitlab.com/hmajid2301/banterbus/ci:v0.1.12
      - job=$(gitlab-ci-local --list-all | tail -n +4 | awk '{print $1}' | gum filter --placeholder "Select job") && gitlab-ci-local "$job"

  tf:init:
    desc: Initialize OpenTofu with backend configuration  
    dir: infra/tf
    vars:
      STATE_NAME: '{{.STATE_NAME | default "default"}}'
      GITLAB_USERNAME: '{{.GITLAB_USERNAME | default "hmajid2301"}}'
    env:
      TF_HTTP_USERNAME: '{{.TF_HTTP_USERNAME | default "gitlab-ci-token"}}'
      TF_HTTP_PASSWORD: '{{.TF_HTTP_PASSWORD | default "$GITLAB_ACCESS_TOKEN"}}'
    cmds:
      - |
        tofu init \
          -backend-config="address=https://gitlab.com/api/v4/projects/59925362/terraform/state/{{.STATE_NAME}}" \
          -backend-config="lock_address=https://gitlab.com/api/v4/projects/59925362/terraform/state/{{.STATE_NAME}}/lock" \
          -backend-config="unlock_address=https://gitlab.com/api/v4/projects/59925362/terraform/state/{{.STATE_NAME}}/lock" \
          -backend-config="username={{.TF_HTTP_USERNAME | default "gitlab-ci-token"}}" \
          -backend-config="password=$TF_HTTP_PASSWORD" \
          -backend-config="lock_method=POST" \
          -backend-config="unlock_method=DELETE" \
          -backend-config="retry_wait_min=5" \
          -reconfigure

  tf:plan:
    desc: Plan OpenTofu changes
    dir: infra/tf
    deps: [tf:init]
    env:
      TF_HTTP_USERNAME: '{{.TF_HTTP_USERNAME | default "gitlab-ci-token"}}'
      TF_HTTP_PASSWORD: '{{.TF_HTTP_PASSWORD | default "$GITLAB_ACCESS_TOKEN"}}'
    cmds:
      - tofu plan ${TF_PLAN_ARGS} -out="plan-default.cache"
      - tofu show -no-color "plan-default.cache" > "plan-default.txt"
      - |
        if command -v jq >/dev/null 2>&1; then
          tofu show -json "plan-default.cache" | jq -r '([.resource_changes[]?.change.actions?]|flatten)|{"create":(map(select(.=="create"))|length),"update":(map(select(.=="update"))|length),"delete":(map(select(.=="delete"))|length)}' > "plan-default.json"
        else
          echo "jq not available, skipping JSON report generation"
        fi

  tf:apply:
    desc: Apply OpenTofu changes
    dir: infra/tf
    env:
      TF_HTTP_USERNAME: '{{.TF_HTTP_USERNAME | default "gitlab-ci-token"}}'
      TF_HTTP_PASSWORD: '{{.TF_HTTP_PASSWORD | default "$GITLAB_ACCESS_TOKEN"}}'
    cmds:
      - task: tf:init
      - |
        if [ -f "plan-default.cache" ]; then
          echo "Applying with cached plan file: plan-default.cache"
          tofu apply -auto-approve "plan-default.cache"
        else
          echo "No plan cache found, running apply without plan file"
          tofu apply -auto-approve
        fi

  tf:validate:
    desc: Validate OpenTofu configuration
    dir: infra/tf
    cmds:
      - tofu fmt -check -recursive
      - tofu init -backend=false
      - tofu validate
