image: nixos/nix

workflow:
  auto_cancel:
    on_new_commit: interruptible

default:
  interruptible: true

variables:
  IMAGE_TAG: v0.1.8
  BANTERBUS_CI_IMAGE: $CI_REGISTRY_IMAGE/ci:$IMAGE_TAG
  BANTERBUS_DB_URI: postgresql://postgres:postgres@docker:5432?sslmode=disable
  DOCKER_HOST: tcp://docker:2375
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

stages:
  - pre
  - deps
  - test
  - build
  - deploy
  - release
  - post

.task:
  stage: test
  image: $BANTERBUS_CI_IMAGE
  variables:
    GOPATH: $CI_PROJECT_DIR/.go
  cache:
    paths:
      - ${GOPATH}/pkg/mod
    policy: pull
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  before_script:
    # INFO: Used to create directory, needed for tests and linter
    - mkdir -p /tmp

.test:
  extends:
    - .task
  # INFO: Not needed for unit tests but simplifies this file a bit.
  services:
    - name: docker:dind
  variables:
     GOTESTSUM_JUNITFILE: "report.xml"
     XDG_DATA_HOME: "/tmp/"
     GOTEST_EXTRA_ARGS: '-args -test.gocoverdir=$CI_PROJECT_DIR/coverage -test.parallel 10'
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
  before_script:
    - mkdir -p $CI_PROJECT_DIR/coverage /tmp  $CI_PROJECT_DIR/e2e/screenshots
    - docker login -u "$CI_DEPENDENCY_PROXY_USER" -p "$CI_DEPENDENCY_PROXY_PASSWORD" "$CI_DEPENDENCY_PROXY_SERVER"
  artifacts:
    paths:
      - coverage
    reports:
      junit: report.xml

.docker:
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""
    IMMUTABLE: "true"
  services:
    - docker:dind
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
  script:
    - echo "experimental-features = nix-command flakes" > /etc/nix/nix.conf
    - nix-env -iA nixpkgs.docker nixpkgs.go-task
    - task docker:publish

.k8s_deploy:
  stage: deploy
  image:
    name: ghcr.io/fluxcd/flux-cli:v2.4.0
    entrypoint: ['']
  timeout: 10m
  script:
    - IMAGE=$(cat image_name.txt)
    - echo "Trying to deploy this image to pod" $IMAGE
    - kubectl config use-context hmajid2301/k3s-config:ms01
    - flux reconcile image repository banterbus
    - kubectl wait --for=jsonpath='{.spec.template.spec.containers[0].image}'="$(cat image_name.txt)" deployment/banterbus -n $NAMESPACE --timeout=600s
    - kubectl wait --for=condition=available --timeout=600s deployment/banterbus -n $NAMESPACE


publish:docker:ci:
  stage: pre
  variables:
    IMAGE: $BANTERBUS_CI_IMAGE
    FLAKE_TARGET: container-ci
    LOCAL_IMAGE: banterbus-dev
    IMMUTABLE: true
  rules:
    - if: $CI_COMMIT_MESSAGE =~ /UPDATE_IMAGE_TAG/
      when: on_success
  extends:
    - .docker
  script:
    - echo "experimental-features = nix-command flakes" > /etc/nix/nix.conf
    - nix-env -iA nixpkgs.docker nixpkgs.go-task
    - task docker:publish

download:dependency:
  extends:
    - .task
  stage: deps
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - go.mod
        - go.sum
  script:
    - go mod download
  cache:
    policy: pull-push

lint:
  extends:
    - .task
  script:
    - task lint

generate:
  extends:
    - .task
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  script:
    - task generate
    - git diff --exit-code

tests:unit:
  extends:
    - .test
  script:
    - task tests:unit -- ${GOTEST_EXTRA_ARGS}

tests:integration:
  extends:
    - .test
  variables:
    BANTERBUS_REDIS_ADDRESS: docker:6379
    BANTERBUS_DB_URI: postgresql://postgres:postgres@docker:5432?sslmode=disable
  script:
    - docker compose --profile test up -d --wait
    - task tests:integration -- ${GOTEST_EXTRA_ARGS}
  after_script:
    - docker ps

test:e2e:
  extends:
    - .test
  variables:
    BANTERBUS_LOG_LEVEL: WARN
    BANTERBUS_ENVIRONMENT: test
    BANTERBUS_REDIS_ADDRESS: docker:6379
    BANTERBUS_DB_URI: postgresql://postgres:postgres@docker:5432?sslmode=disable
    BANTERBUS_DB_HOST: docker
    BANTERBUS_DB_PORT: '5432'
    BANTERBUS_DB_USERNAME: postgres
    BANTERBUS_DB_PASSWORD: postgres
    BANTERBUS_DB_NAME: banterbus
    BANTERBUS_JWKS_URL: http://docker:9091/default/jwks
    BANTERBUS_PLAYWRIGHT_HEADLESS: true
    OTEL_EXPORTER_OTLP_ENDPOINT: http://localhost:9999
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: http://localhost:9999/v1/traces  
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: http://localhost:9999/v1/metrics
    GOTEST_EXTRA_ARGS: '-test.parallel 10'
  script:
    - docker compose --profile test up -d --wait
    - |
      # Run migrations first by starting and stopping the app
      echo "Running database migrations..."
      timeout 30s task run || true
      sleep 2
    - |
      # Populate main database with test data for e2e tests
      cat > populate_db.go << 'EOF'
      package main
      
      import (
        "context"
        "database/sql"
        "embed"
        "fmt"
        "os"
        "gitlab.com/hmajid2301/banterbus/internal/banterbustest"
        "github.com/jackc/pgx/v5/pgxpool"
        pgxUUID "github.com/vgarvardt/pgx-google-uuid/v5"
        "github.com/jackc/pgx/v5"
        "github.com/pressly/goose/v3"
        _ "github.com/jackc/pgx/v5/stdlib"
      )
      
      //go:embed internal/store/db/sqlc/migrations/*.sql
      var migrations embed.FS
      
      func main() {
        ctx := context.Background()
        
        // Use the same DB URI format as the tests
        uri := fmt.Sprintf("postgresql://%s:%s@%s:%s/%s?sslmode=disable",
          os.Getenv("BANTERBUS_DB_USERNAME"),
          os.Getenv("BANTERBUS_DB_PASSWORD"), 
          os.Getenv("BANTERBUS_DB_HOST"),
          os.Getenv("BANTERBUS_DB_PORT"),
          os.Getenv("BANTERBUS_DB_NAME"))
        
        fmt.Println("Connecting to:", uri)
        
        // Run migrations first
        sqlDB, err := sql.Open("pgx", uri)
        if err != nil {
          fmt.Printf("Failed to open database: %v\n", err)
          return
        }
        defer sqlDB.Close()
        
        goose.SetBaseFS(migrations)
        if err := goose.SetDialect("postgres"); err != nil {
          fmt.Printf("Failed to set goose dialect: %v\n", err)
          return
        }
        
        err = goose.Up(sqlDB, "internal/store/db/sqlc/migrations")
        if err != nil {
          fmt.Printf("Failed to run migrations: %v\n", err)
          return
        }
        fmt.Println("Migrations completed successfully")
        
        // Now populate data
        pgxConfig, err := pgxpool.ParseConfig(uri)
        if err != nil {
          fmt.Printf("Parse config error: %v\n", err)
          return
        }
        
        pgxConfig.AfterConnect = func(_ context.Context, conn *pgx.Conn) error {
          pgxUUID.Register(conn.TypeMap())
          return nil
        }
        
        pool, err := pgxpool.NewWithConfig(ctx, pgxConfig)
        if err != nil {
          fmt.Printf("Pool creation error: %v\n", err)
          return
        }
        defer pool.Close()
        
        err = banterbustest.FillWithDummyData(ctx, pool)
        if err != nil {
          fmt.Printf("Fill data error: %v\n", err)
          return
        }
        
        fmt.Println("Successfully populated database with test data")
      }
      EOF
      go run populate_db.go
    - task tests:e2e -- ${GOTEST_EXTRA_ARGS}
  artifacts:
    when: always
    reports:
      junit: report.xml
    paths:
      - coverage
      - tests/e2e/videos/*
      - tests/e2e/*.png

combine:coverage:
  stage: build
  extends:
    - .task
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
  script:
    - task coverage
  coverage: /total:\s+\(statements\)\s+\d+.\d+%/
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

publish:docker:dev:
  stage: build
  extends:
    - .docker
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  script:
    - echo "experimental-features = nix-command flakes" > /etc/nix/nix.conf
    - nix-env -iA nixpkgs.docker nixpkgs.go-task
    - task docker:build
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
    - docker tag banterbus:latest $CI_REGISTRY_IMAGE:$CI_MERGE_REQUEST_IID
    - docker push $CI_REGISTRY_IMAGE:$CI_MERGE_REQUEST_IID
    - echo "$CI_REGISTRY_IMAGE:$CI_MERGE_REQUEST_IID" > image_name.txt
  artifacts:
    paths:
      - image_name.txt

check_deploy:dev:
  extends: .k8s_deploy
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  variables:
    NAMESPACE: dev
  dependencies:
    - publish:docker:dev
  allow_failure: true

# smoke:tests:dev:e2e:
#   extends:
#     - .test
#   stage: post
#   variables:
#     BANTERBUS_PLAYWRIGHT_URL: https://dev.banterbus.games
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#   script:
#    - task tests:e2e -- -v -run 'TestE2ERound/Should_successfully_complete_an_entire_game_where_the_fibber_is_caught_first_time'
#   artifacts:
#     when: always
#     paths:
#       - coverage
#       - tests/e2e/videos/*
#       - tests/e2e/*.png
#   dependencies:
#     - check_deploy:dev

get:mr:iid:
  image: $BANTERBUS_CI_IMAGE
  stage: deploy
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_TAG
  script:
    - |
      # Fetch merged MRs associated with this commit
      RESPONSE=$(curl -sS \
        --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
        -w "\n%{http_code}" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/commits/$CI_COMMIT_SHA/merge_requests?state=merged")

      HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
      BODY=$(echo "$RESPONSE" | head -n -1)

      if [ "$HTTP_STATUS" != "200" ]; then
        echo "ERROR: API request failed with status $HTTP_STATUS"
        echo "Response body:"
        echo "$BODY"
        exit 1
      fi

      # Extract most recent MR IID
      MR_IID=$(echo "$BODY" | jq -r 'sort_by(.merged_at) | last | .iid // empty')

      if [ -n "$MR_IID" ]; then
        echo "Detected MR IID: $MR_IID"
        echo "MR_IID=$MR_IID" >> build.env
      else
        echo "No merged MR found for commit $CI_COMMIT_SHA"
        exit 1
      fi
  artifacts:
    reports:
      dotenv: build.env

#INFO: Because Nix docker builds are immutable, we can just rebuild the image here for production
# If we wanted to be more efficient we could work out way to retag a dev image. But this is good enough for now.
deploy:prod:
  variables:
    FLAKE_TARGET: container
    LOCAL_IMAGE: banterbus
    IMAGE_NAME: $CI_REGISTRY_IMAGE:$MR_IID
    FLY_CONFIG: fly.prod.toml
  extends:
    - .k8s_deploy
  needs: ["get:mr:iid"]
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_COMMIT_TAG || $CI_COMMIT_BRANCH == "main"
  environment:
    name: production

check_deploy:prod:
  extends: .k8s_deploy
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_COMMIT_TAG || $CI_COMMIT_BRANCH == "main"
  variables:
    NAMESPACE: prod
  dependencies:
    - deploy:prod

release:
  stage: release
  rules:
    - if: $CI_COMMIT_TAG
  extends:
    - .task
  variables:
    GIT_DEPTH: 0
  script:
    - task release

# TODO: fix smoke tests
# smoke:tests:prod:e2e:
#   extends:
#     - .test
#   stage: post
#   variables:
#     BANTERBUS_PLAYWRIGHT_URL: https://banterbus.games
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#       when: always
#     - if: $CI_COMMIT_TAG || $CI_COMMIT_BRANCH == "main"
#   script:
#    - task tests:e2e -- -v -run 'TestE2ERound/Should_successfully_complete_an_entire_game_where_the_fibber_is_caught_first_time'
#   after_script:
#     - |
#       if [ "$CI_JOB_STATUS" != "success" ]; then
#         curl -X POST \
#             -H "Authorization: Bearer $NOTIFY_TOKEN" "https://notify.homelab.haseebmajid.dev/message" \
#             -F "title=Job Failed" \
#             -F "message=The smoke:tests:e2e job has failed in the pipeline. Job URL: $CI_JOB_URL"
#       fi
#   artifacts:
#     when: always
#     paths:
#       - coverage
#       - tests/e2e/videos/*
#       - tests/e2e/*.png
#   dependencies:
#     - check_deploy:prod
