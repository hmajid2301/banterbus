image: nixos/nix

workflow:
  auto_cancel:
    on_new_commit: interruptible

default:
  interruptible: true

variables:
  IMAGE_TAG: v0.1.14
  BANTERBUS_CI_IMAGE: $CI_REGISTRY_IMAGE/ci:$IMAGE_TAG
  TF_ROOT: ${CI_PROJECT_DIR}/infra/tf
  TF_STATE_NAME: default
  TF_ADDRESS: ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/default
  TF_USERNAME: gitlab-ci-token
  TF_PASSWORD: ${CI_JOB_TOKEN}
  OPENBAO_ADDRESS: https://openbao.homelab.haseebmajid.dev
  # OpenTofu Report variables
  PLAN: plan.cache
  PLAN_JSON: plan.json

stages:
  - pre
  - deps
  - test
  - build
  - deploy
  - review
  - post

.task:
  stage: test
  image: $BANTERBUS_CI_IMAGE
  variables:
    GOPATH: $CI_PROJECT_DIR/.go
  cache:
    paths:
      - ${GOPATH}/pkg/mod
    policy: pull
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  before_script:
    - mkdir -p /tmp coverage

.test:
  extends:
    - .task

  services:
    - name: docker:dind
  variables:
     BANTERBUS_DB_URI: postgresql://postgres:postgres@docker:5432/?sslmode=disable
     GOTESTSUM_JUNITFILE: "report.xml"
     XDG_DATA_HOME: "/tmp/"
     GOTEST_EXTRA_ARGS: '-args -test.gocoverdir=$CI_PROJECT_DIR/coverage -test.parallel 10'
     DOCKER_HOST: tcp://docker:2375
     DOCKER_DRIVER: overlay2
     DOCKER_TLS_CERTDIR: ""
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
  before_script:
    - mkdir -p /tmp $CI_PROJECT_DIR/coverage $CI_PROJECT_DIR/tests/e2e/videos
  artifacts:
    paths:
      - coverage
    reports:
      junit: report.xml

.tailscale:
  before_script:
    - |
        echo "Setting up Tailscale connection..."
        tailscaled --state="mem:" --statedir=/var/lib/tailscale &
        sleep 2
        tailscale up --authkey=${TAILSCALE_AUTH_KEY} --hostname="gitlab-$(cat /etc/hostname)" --accept-routes --ssh
        echo "Tailscale DNS setup complete"
    - |
      cat > /etc/resolv.conf << EOF
      nameserver 1.1.1.1
      nameserver 8.8.8.8
      nameserver 100.100.100.100
      EOF

.docker:
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""
    IMMUTABLE: "true"
  services:
    - docker:dind
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
  before_script:
    - nix-env -iA nixpkgs.docker nixpkgs.go-task nixpkgs.attic-client nixpkgs.tailscale nixpkgs.cacert
    - mkdir -p /etc/nix
    - |
      cat >> /etc/nix/nix.conf << EOF
      experimental-features = nix-command flakes
      extra-platforms = x86_64-linux i686-linux
      system-features = benchmark big-parallel nixos-test i686
      substituters = https://attic.homelab.haseebmajid.dev/system?priority=43 https://nix-community.cachix.org?priority=41 https://numtide.cachix.org?priority=42 https://cache.nixos.org/
      trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= system:5M8uBPjS68HTadSbeCs0Jiu0Z1tJBNdahtKBCXhl+Z0= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs= numtide.cachix.org-1:2ps1kLBUWjxIneOy1Ik6cQjb41X0iXVXeHigGmycPPE=
      EOF
    - |
      if [ -n "$ATTIC_AUTH_KEY" ]; then
        echo "machine attic.homelab.haseebmajid.dev password $ATTIC_AUTH_KEY" > /etc/nix/netrc
      fi
    - mkdir -p ~/.ssh /etc/ssh
    - chmod 700 ~/.ssh
    - ssh-keygen -t ed25519 -N "" -f ~/.ssh/id_ed25519
    - ssh-keygen -t ed25519 -N "" -f /etc/ssh/ssh_host_ed25519_key
    - |
      cat >> ~/.ssh/config << EOF
      Host *
        StrictHostKeyChecking no
        UserKnownHostsFile /dev/null
      EOF
    - export SSH_ASKPASS_REQUIRE=never
    - eval $(ssh-agent -s)
    - ssh-add ~/.ssh/id_ed25519 2>/dev/null
    - !reference [.tailscale, before_script]
    - |
      if [ -n "$ATTIC_AUTH_KEY" ]; then
        echo "Setting up Attic binary cache..."
        attic login homelab https://attic.homelab.haseebmajid.dev $ATTIC_AUTH_KEY
        attic use homelab:main || true
        attic watch-store homelab:main &
      else
        echo "ATTIC_AUTH_KEY not set, skipping Attic setup"
       fi

.tofu:
  extends: .task
  variables:
    TF_VAR_openbao_token: $OPENBAO_TOKEN
    TF_VAR_openbao_address: $OPENBAO_ADDRESS
    TF_VAR_remote_state_address: $TF_ADDRESS
    TF_VAR_username: $TF_USERNAME
    TF_VAR_access_token: $TF_PASSWORD
    TF_VAR_kubeconfig_path: ~/.kube/config
    TF_VAR_kubeconfig_context: hmajid2301/k8s-gitops:k8s
    GITLAB_USERNAME: $TF_USERNAME
    GITLAB_ACCESS_TOKEN: $TF_PASSWORD
    TF_HTTP_USERNAME: $TF_USERNAME
    TF_HTTP_PASSWORD: $TF_PASSWORD
    TMPDIR: /tmp
    TMP: /tmp
    TEMP: /tmp
  before_script:
    - !reference [.tailscale, before_script]
    - mkdir -p ~/.kube
    - kubectl config use-context hmajid2301/k8s-gitops:k8s
    - kubectl config view --raw > ~/.kube/config
    - chmod 600 ~/.kube/config
    - cd $TF_ROOT
    - |
      echo "Setting up Terraform environment..."
      mkdir -p /tmp .terraform/providers
      chmod 755 /tmp
      export TMPDIR=/tmp
      export TMP=/tmp
      export TEMP=/tmp
  cache:
    key: tofu-providers-$CI_COMMIT_REF_SLUG
    paths:
      - $TF_ROOT/.terraform/providers
    policy: pull-push

.tofu:plan:
  extends: .tofu
  stage: build
  script:
    - task tf:plan
  artifacts:
    name: plan
    paths:
      - $TF_ROOT/plan-default.cache
      - $TF_ROOT/plan-default.txt
      - $TF_ROOT/plan-default.json
    reports:
      terraform: $TF_ROOT/plan-default.json
    expire_in: 1 week

.tofu:apply:
  extends: .tofu
  stage: deploy
  script:
    - task tf:apply
  when: manual

.k8s_deploy:
  stage: deploy
  image:
    name: ghcr.io/fluxcd/flux-cli:v2.4.0
    entrypoint: ['']
  timeout: 10m
  before_script:
    - kubectl config use-context hmajid2301/k8s-gitops:k8s
  script:
    - IMAGE=$(cat image_name.txt)
    - echo "Trying to deploy this image" $IMAGE
    - flux reconcile source git banterbus
    - flux reconcile image repository banterbus
    - echo "Current deployment image:"
    - kubectl get deployment banterbus -n $NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].image}' || echo "Deployment not found"
    - echo "Waiting for rollout to complete..."
    - kubectl rollout status deployment/banterbus -n $NAMESPACE --timeout=600s
    - echo "Deployment completed. Final image:"
    - kubectl get deployment banterbus -n $NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].image}'

.promote:
  stage: deploy
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - apk add --no-cache curl jq
    - export TARGET_TAG="$ENVIRONMENT-$CI_COMMIT_SHA-$(date +%s)"
    - echo $CI_REGISTRY_IMAGE:$TARGET_TAG > image_name.txt
    - |
      echo "Finding merge request for commit $CI_COMMIT_SHA"
      MR_IID=$(curl -s --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/commits/$CI_COMMIT_SHA/merge_requests" | \
        jq -r '.[0].iid // empty')
      if [ -z "$MR_IID" ]; then
        echo "No merge request found for commit $CI_COMMIT_SHA"
        echo "Searching recent merge requests..."
        MR_IID=$(curl -s --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=merged&order_by=updated_at&sort=desc&per_page=10" | \
          jq -r --arg sha "$CI_COMMIT_SHA" '.[] | select(.merge_commit_sha == $sha) | .iid' | head -1)
      fi
      if [ -z "$MR_IID" ]; then
        echo "Could not find merge request for commit $CI_COMMIT_SHA"
        exit 1
      fi
      echo "Found merge request IID - $MR_IID"
      export MR_IID=$MR_IID
  script:
    - echo "Promoting merged MR image to $ENVIRONMENT"
    - echo "Source image - $CI_REGISTRY_IMAGE:$MR_IID (MR $MR_IID)"
    - echo "Target image - $CI_REGISTRY_IMAGE:$TARGET_TAG"
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
    - echo "Pulling image from MR $MR_IID..."
    - docker pull $CI_REGISTRY_IMAGE:$MR_IID
    - echo "Tagging as $ENVIRONMENT image $CI_REGISTRY_IMAGE:$TARGET_TAG"
    - docker tag $CI_REGISTRY_IMAGE:$MR_IID $CI_REGISTRY_IMAGE:$TARGET_TAG
    - echo "Pushing $ENVIRONMENT image to registry"
    - docker push $CI_REGISTRY_IMAGE:$TARGET_TAG
    - echo "$ENVIRONMENT image ready - $CI_REGISTRY_IMAGE:$TARGET_TAG"
  artifacts:
    paths:
      - image_name.txt

publish:docker:ci:
  stage: pre
  variables:
    IMAGE: $BANTERBUS_CI_IMAGE
    FLAKE_TARGET: container-ci
    LOCAL_IMAGE: banterbus-dev
    IMMUTABLE: true
  rules:
    - if: $CI_COMMIT_MESSAGE =~ /UPDATE_IMAGE_TAG/
      when: on_success
  extends:
    - .docker
  script:
    - task docker:publish

download:dependency:
  extends:
    - .task
  stage: deps
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - go.mod
        - go.sum
  script:
    - go mod download
  cache:
    policy: pull-push

lint:
  extends:
    - .task
  script:
    - task lint

generate:
  extends:
    - .task
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  script:
    - task generate
    - git diff --exit-code

tests:unit:
  extends:
    - .test
  script:
    - task tests:unit -- ${GOTEST_EXTRA_ARGS}

tests:integration:
  extends:
    - .test
  variables:
    BANTERBUS_REDIS_HOST: docker
    BANTERBUS_REDIS_PORT: 6379
    BANTERBUS_DB_HOST: docker
    BANTERBUS_DB_PORT: 5432
    BANTERBUS_DB_USER: postgres
    BANTERBUS_DB_PASSWORD: postgres
    BANTERBUS_DB_NAME: banterbus
    POSTGRES_HOST: docker
    POSTGRES_DB: banterbus
    BANTERBUS_MIGRATIONS_DIR: $CI_PROJECT_DIR/internal/store/db/sqlc/migrations
    BANTERBUS_SEED_DATA_PATH: $CI_PROJECT_DIR/docker/postgres-init/01-seed-data.sql
  script:
    - docker compose --profile test up -d
    - task tests:integration -- ${GOTEST_EXTRA_ARGS}

test:e2e:
  extends:
    - .test
  variables:
    BANTERBUS_LOG_LEVEL: INFO
    BANTERBUS_ENVIRONMENT: test
    BANTERBUS_REDIS_ADDRESS: docker:6379
    BANTERBUS_DB_HOST: docker
    BANTERBUS_DB_PORT: 5432
    BANTERBUS_DB_USERNAME: postgres
    BANTERBUS_DB_PASSWORD: postgres
    BANTERBUS_DB_NAME: banterbus
    BANTERBUS_JWKS_URL: http://docker:9091/default/jwks
    BANTERBUS_PLAYWRIGHT_HEADLESS: true
    GOCOVERDIR: $CI_PROJECT_DIR/coverage/e2e
    SHOW_VOTING_SCREEN_FOR: 10s
    RUN_WITH_COVERAGE: true
    BANTERBUS_WEBSERVER_PORT: 8081
    BANTERBUS_WEBSERVER_HOST: 0.0.0.0
    BANTERBUS_PLAYWRIGHT_URL: http://localhost:8081
    OTEL_EXPORTER_OTLP_ENDPOINT: ""
    OTEL_SERVICE_NAME: banterbus
    OTEL_SERVICE_VERSION: $CI_COMMIT_SHA
    OTEL_RESOURCE_ATTRIBUTES: deployment.environment=ci,service.namespace=e2e-tests,ci.job_id=$CI_JOB_ID,ci.pipeline_id=$CI_PIPELINE_ID,ci.commit_sha=$CI_COMMIT_SHA,ci.merge_request_iid=$CI_MERGE_REQUEST_IID
    POSTGRES_HOST: docker
    POSTGRES_DB: banterbus
    BANTERBUS_MIGRATIONS_DIR: $CI_PROJECT_DIR/internal/store/db/sqlc/migrations
    BANTERBUS_SEED_DATA_PATH: $CI_PROJECT_DIR/docker/postgres-init/01-seed-data.sql
  script:
    - docker compose --profile test up -d
    - go mod download
    - task tests:e2e -- ${GOTEST_EXTRA_ARGS}
  tags:
    - powerful
    - homelab
  artifacts:
     when: always
     reports:
       junit: report.xml
     paths:
       - coverage
       - tests/e2e/videos
       - tests/e2e/*.png

combine:coverage:
  stage: build
  extends:
    - .task
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
  script:
    - task coverage
    # GitLab CI reports business logic coverage only
    # Excludes: mocks (*/mocks/*), generated templates (*_templ.go), views (/views/), test helpers (banterbustest)
    # This provides a more accurate representation of actual code coverage vs generated/mock code
    - gocover-cobertura < coverage/business-logic.out > coverage.xml || touch coverage.xml
    - echo ""
    - echo "GitLab CI Coverage (Business Logic Only - excludes mocks/generated files):"
    - go tool cover -func=coverage/business-logic.out | tail -1
  coverage: /total:\s+\(statements\)\s+(\d+\.\d+)%/
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage/

tofu:validate:
  extends:
    - .tofu
  script:
    - cd $TF_ROOT
    - mkdir -p /tmp .terraform/providers
    - |
      cat > /etc/resolv.conf << EOF
      nameserver 8.8.8.8
      nameserver 1.1.1.1
      nameserver 100.100.100.100
      EOF
    - task tf:init
    - task tf:validate
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - "infra/tf/**/*"
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - "infra/tf/**/*"

# Removed: tofu:plan:dev - now using single shared plan
# See tofu:plan:shared which handles both dev and prod infrastructure

tofu:plan:
  extends: .tofu:plan
  variables:
    ENVIRONMENT: default  # For artifact naming only
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - infra/tf/**/*
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - infra/tf/**/*
  needs:
    - job: tofu:validate
      optional: true

tofu:apply:
  extends: .tofu:apply
  variables:
    ENVIRONMENT: default  # For artifact naming only
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - infra/tf/**/*
      when: manual
  needs:
    - tofu:plan
  dependencies:
    - tofu:plan

publish:docker:
  stage: build
  extends:
    - .docker
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  script:
    - task docker:build
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
    - docker tag banterbus:latest $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker tag banterbus:latest $CI_REGISTRY_IMAGE:$CI_MERGE_REQUEST_IID
    - docker push $CI_REGISTRY_IMAGE:$CI_MERGE_REQUEST_IID
    - echo "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA" > image_name.txt
  artifacts:
    paths:
      - image_name.txt

deploy:review:
  stage: review
  image:
    name: ghcr.io/fluxcd/flux-cli:v2.4.0
    entrypoint: ['']
  environment:
    name: review/$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    url: https://mr-$CI_MERGE_REQUEST_IID.dev.banterbus.games
    auto_stop_in: 1 day
  timeout: 15m
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_LABELS =~ /deploy\/flux-preview/
  variables:
    NAMESPACE: dev
    REVIEW_APP_NAME: banterbus-mr-$CI_MERGE_REQUEST_IID
  needs:
    - publish:docker
  script:
    - IMAGE=$(cat image_name.txt)
    - echo "üöÄ Deploying review app for MR $CI_MERGE_REQUEST_IID"
    - echo "Image - $IMAGE"
    - echo "Expected URL - https://mr-$CI_MERGE_REQUEST_IID.dev.banterbus.games"
    - kubectl config use-context hmajid2301/k8s-gitops:k8s
    - echo "üîÑ Forcing ResourceSet input provider reconciliation..."
    - kubectl annotate resourcesetinputprovider banterbus-merge-requests -n flux-system reconcile.fluxcd.io/requestedAt="$(date -u +%Y-%m-%dT%H:%M:%SZ)" --overwrite
    - echo "‚è≥ Waiting for ResourceSet to detect MR $CI_MERGE_REQUEST_IID..."
    - |
      for i in {1..30}; do
        if kubectl get resourcesetinputprovider banterbus-merge-requests -n flux-system -o yaml | grep -q 'id: "'"$CI_MERGE_REQUEST_IID"'"'; then
          echo "‚úÖ MR $CI_MERGE_REQUEST_IID detected by ResourceSet"
          break
        fi
        echo "Waiting... (attempt $i/30)"
        sleep 10
      done
    - echo "üîÑ Forcing ResourceSet reconciliation..."
    - kubectl annotate resourceset gitlab-preview-environments -n flux-system reconcile.fluxcd.io/requestedAt="$(date -u +%Y-%m-%dT%H:%M:%SZ)" --overwrite
    - echo "‚è≥ Waiting for Kustomization $REVIEW_APP_NAME to be created..."
    - |
      for i in {1..60}; do
        if kubectl get kustomization $REVIEW_APP_NAME -n $NAMESPACE >/dev/null 2>&1; then
          echo "‚úÖ Kustomization $REVIEW_APP_NAME created"
          break
        fi
        echo "Waiting for Kustomization... (attempt $i/60)"
        sleep 5
      done
    - echo "‚è≥ Waiting for Kustomization $REVIEW_APP_NAME to be ready..."
    - kubectl wait --for=condition=Ready kustomization/$REVIEW_APP_NAME -n $NAMESPACE --timeout=300s
    - echo "üîç Verifying Kubernetes resources..."
    - kubectl get deployment $REVIEW_APP_NAME -n $NAMESPACE -o wide
    - kubectl get service $REVIEW_APP_NAME -n $NAMESPACE -o wide
    - kubectl get ingress $REVIEW_APP_NAME -n $NAMESPACE -o wide
    - echo "üîç Checking pod status..."
    - kubectl get pods -n $NAMESPACE -l app=$REVIEW_APP_NAME -o wide
    - kubectl wait --for=condition=Ready pod -l app=$REVIEW_APP_NAME -n $NAMESPACE --timeout=300s
    - echo "üß™ Testing service connectivity..."
    - kubectl run test-pod-$CI_MERGE_REQUEST_IID --rm -i --image=curlimages/curl --restart=Never -- curl -s http://$REVIEW_APP_NAME.$NAMESPACE.svc.cluster.local | head -5 || echo "Service test completed"
    - echo "üîç Verifying ingress configuration..."
    - kubectl get ingress $REVIEW_APP_NAME -n $NAMESPACE -o jsonpath='{.spec.rules[0].host}'
    - echo ""
    - echo "üéâ Review app deployment completed!"
    - echo "üìç MR - $CI_MERGE_REQUEST_IID"
    - echo "üñºÔ∏è  Image - $IMAGE"
    - echo "üåê URL - https://mr-$CI_MERGE_REQUEST_IID.dev.banterbus.games"
    - echo "üìä Resources - Deployment, Service, Ingress created in $NAMESPACE namespace"

promote:dev:
  extends: .promote
  variables:
    ENVIRONMENT: dev
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

deploy:dev:
  extends: .k8s_deploy
  stage: deploy
  environment:
    name: dev
    url: https://dev.banterbus.games
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  variables:
    NAMESPACE: dev
  needs:
    - promote:dev

# smoke:tests:dev:
#   extends:
#     - .test
#   stage: post
#   variables:
#     BANTERBUS_PLAYWRIGHT_URL: https://dev.banterbus.games
#   rules:
#     - if: $CI_COMMIT_BRANCH == "main"
#       when: manual
#       allow_failure: true
#   needs:
#     - deploy:dev
#   script:
#    - task tests:e2e -- -v -run 'TestE2ERound/Should_successfully_complete_an_entire_game_where_the_fibber_is_caught_first_time'
#   artifacts:
#     when: always
#     paths:
#       - coverage
#       - tests/e2e/videos/*
#       - tests/e2e/*.png

promote:prod:
  extends: .promote
  variables:
    ENVIRONMENT: prod
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual

deploy:prod:
  extends: .k8s_deploy
  stage: deploy
  environment:
    name: prod
    url: https://banterbus.games
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  variables:
    NAMESPACE: prod
  needs:
    - promote:prod

# smoke:tests:prod:
#   extends:
#     - .test
#   stage: post
#   variables:
#     BANTERBUS_PLAYWRIGHT_URL: https://banterbus.games
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#       when: always
#     - if: $CI_COMMIT_BRANCH == "main"
#       when: manual
#   needs:
#     - deploy:prod
#   script:
#    - task tests:e2e -- -v -run 'TestE2ERound/Should_successfully_complete_an_entire_game_where_the_fibber_is_caught_first_time'
#   after_script:
#     - |
#       if [ "$CI_JOB_STATUS" != "success" ]; then
#         curl -X POST \
#             -H "Authorization: Bearer $NOTIFY_TOKEN" "https://notify.homelab.haseebmajid.dev/message" \
#             -F "title=Job Failed" \
#             -F "message=The smoke:tests:e2e job has failed in the pipeline. Job URL: $CI_JOB_URL"
#       fi
#   artifacts:
#     when: always
#     paths:
#       - coverage
#       - tests/e2e/videos/*
#       - tests/e2e/*.png
